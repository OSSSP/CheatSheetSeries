# Введение

Основное назначение данного документа — описание понятного, простого, применимого на практике руководства по обеспечению безопасности проверки входных данных в приложениях.

# Цель проверки входных данных

Проверка входных данных выполняется для подтверждения ввода в систему только правильно сформированных данных, предотвращая тем самым появление некорректных записей в базе данных, способных вызвать сбои в работе других компонентов. Проверку необходимо проводить на самых ранних этапах обработки, предпочтительно на этапе получения данных от внешнего источника.

Проверку должны проходить все данные от потенциально ненадежных источников, т.е. не только данные, полученные от веб-клиентов, но и данные, передаваемые через внутренние серверы экстрасети от [поставщиков, партнеров, производителей или регуляторов](https://badcyber.com/several-polish-banks-hacked-information-stolen-by-unknown-attackers/), которые могут быть скомпрометированы и использоваться для рассылки вредоносных данных.

Проверка входных данных не должна использоваться в качестве *основного* метода предотвращения [Межсайтовых выполнений сценариев](XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet.md), [Внедрений SQL-кода](SQL_Injection_Prevention_Cheat_Sheet.md) и прочих вредоносных действий, которым посвящены соответствующие [памятки](https://www.owasp.org/index.php/OWASP_Cheat_Sheet_Series), но при правильной реализации она может значительно сократить негативные последствия атак.

# Принципы проверки входных данных

Проверка должна осуществляться на **синтаксическом** и **семантическом** уровнях.

**Синтаксическая** проверка должна подтверждать правильность синтаксиса структурированных полей (например, номера социального страхования, даты, обозначения денежных единиц).

**Семантическая** проверка должна подтверждать правильность вводимых *значений* в контексте бизнеса (например, дата начала предшествует дате окончания, цена находится в рамках предполагаемого диапазона).

Атаки необходимо предотвращать на самых ранних стадиях обработки запросов пользователя (злоумышленника). Проверка входных данных может быть использована для обнаружения ввода вредоносных данных, до того как они будут обработаны приложением.

# Реализация проверки входных данных

Проверка входных данных может быть реализована любым программным способом, позволяющим эффективно подтверждать синтаксическую и семантическую правильность, например:

- средствами проверки типов данных, доступными во фреймворках веб-приложений (например, [Django Validators](https://docs.djangoproject.com/en/1.11/ref/validators/) или [Apache Commons Validators](https://commons.apache.org/proper/commons-validator/apidocs/org/apache/commons/validator/package-summary.html#doc.Usage.validator));
- проверкой входных данных на соответствие [JSON Schema](http://json-schema.org/) и [XML Schema (XSD)](https://www.w3schools.com/xml/schema_intro.asp);
- преобразованием типов (например, используя `Integer.parseInt()` на Java, `int()` на Python) со строгой обработкой исключений;
- проверкой минимальных и максимальных значений для числовых параметров и дат, проверкой минимальной и максимальной длины для строк;
- использованием только допустимых значений для небольших наборов строковых параметров (например, дней недели);
- регулярными выражениями для структурированных данных, которые применяются ко всей строке ввода `(^...$)` и **не** содержат подстановочных знаков "любой символ" (например, `.` или `\S`).

## Белые и черные списки

Распространенной ошибкой является использование черных списков для обнаружения потенциально опасных символов и шаблонов (например, апострофов `'`, строк `1=1` или тегов `<script>`), поскольку злоумышленники легко обходят подобные фильтры.

Более того, подобные фильтры зачастую мешают вводу разрешенных данных (например, как в случае с `O'Brian`), в которых символ ' является полностью легитимным. Более подробную информацию по обходу XSS-фильтров можно найти на [этой странице вики](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet).

Проверка по белому списку вполне подходит для любых полей ввода данных. Белый список точно определяет что РАЗРЕШЕНО, а все остальное, по определению, является запрещенным.

Если данные хорошо структурированы (например, даты, номера социального страхования, почтовые индексы, адреса электронной почты и т. п.), то разработчик может создать очень точный шаблон для проверки подобных данных, как правило основанный на регулярных выражениях.

Если поле ввода данных представляет собой фиксированный набор опций (например, раскрывающийся список или ограниченный список выбора вариантов), то входные данные должны просто совпадать с одним из значений, предлагаемых пользователю.

## Проверка произвольного Юникод-текста

Произвольный текст, особенно содержащий символы Юникода, считается трудным для проверки из-за большого количества символов, которые необходимо включать в белый список.

Также входные данные в форме произвольного текста показывают важность правильного, зависящего от контекста кодирования выходных данных и демонстрируют, что проверка входных данных **не** является основным средством обеспечения защиты от межсайтового выполнения сценариев. Если пользователям по каким-то причинам требуется использовать апостроф `'` или знак "менее чем" `<` в поле комментариев, то приложение должно обеспечивать корректную обработку подобных данных на протяжении всего их жизненного цикла.

Базовые средства проверки данных, вводимых в виде произвольного текста:

- **нормализация** — необходимо обеспечить каноническое кодирование всего текста, а также отсутствие любых недопустимых символов;
- **белые списки категорий символов** — Юникод позволяет создавать белые списки категорий, таких как "десятичные цифры" или "буквы", в которые могут входить не только латинские, но и другие, широко используемые символы, например, арабские, кириллические, китайские, японские или корейские;
- **белые списки отдельных символов** — для случаев когда в именах допускается использование букв и иероглифов, но требуется также разрешить использование апострофа `'` для ирландских имен без разрешения всех знаков (категории) пунктуации.

Ссылки:

- [Проверка данных, вводимых в виде произвольного Юникод-текста, на Python](https://ipsec.pl/python/2017/input-validation-free-form-unicode-text-python.html)

## Регулярные выражения

Создание регулярных выражений является довольно сложным процессом и не рассматривается в данном документе.

В интернете существует множество ресурсов, посвященных написанию регулярных выражений, включая этот [сайт](https://www.regular-expressions.info/) и [репозиторий проверочных регулярных выражений OWASP](https://www.owasp.org/index.php/OWASP_Validation_Regex_Repository).

Таким образом, проверка входных данных должна:

- применяться ко всем входным данным, как минимум;
- определять разрешенный для ввода набор символов;
- определять минимальный и максимальный размер данных (например, `{1,25}` ).

# Примеры регулярных выражений для белых списков

Проверка почтовых индексов США (5 цифр и опционально -4)

```text
^\d{5}(-\d{4})?$
```

Проверка для выбора штата США из раскрывающегося меню

```text
^(AA|AE|AP|AL|AK|AS|AZ|AR|CA|CO|CT|DE|DC|FM|FL|GA|GU|
HI|ID|IL|IN|IA|KS|KY|LA|ME|MH|MD|MA|MI|MN|MS|MO|MT|NE| 
NV|NH|NJ|NM|NY|NC|ND|MP|OH|OK|OR|PW|PA|PR|RI|SC|SD|TN|
TX|UT|VT|VI|VA|WA|WV|WI|WY)$
```

**Пример использования регулярных выражений на Java**

Пример проверки параметра "почтовый индекс" с помощью регулярного выражения:

```java
private static final Pattern zipPattern = Pattern.compile("^\d{5}(-\d{4})?$");

public void doPost( HttpServletRequest request, HttpServletResponse response) {
  try {
      String zipCode = request.getParameter( "zip" );
      if ( !zipPattern.matcher( zipCode ).matches()  {
          throw new YourValidationException( "Improper zipcode format." );
      }
      // делайте здесь, что хотите, если проверка прошла успешно ..
  } catch(YourValidationException e ) {
      response.sendError( response.SC_BAD_REQUEST, e.getMessage() );
  }
}
```

Можно использовать различные бесплатные пакеты, которые содержат уже настроенные проверки по белым спискам. Например:

- [Apache Commons Validator](http://commons.apache.org/proper/commons-validator/)

# Проверки на стороне клиента и на стороне сервера

Помните, что злоумышленники могут обойти любую JavaScript-проверку входных данных, выполняемую на стороне клиента, отключив JavaScript или использовав веб-прокси. Убедитесь, что все проверки входных данных, выполняемые в клиенте, также выполняются на сервере.

# Проверка насыщенного пользовательского контента

Проверять насыщенный контент, предоставляемый пользователями, очень трудно. Более подробную информацию см. в памятке по предотвращению межсайтового выполнения сценариев в разделе [Обработка HTML-разметки с использованием специальных библиотек](Cross_Site_Scripting_Prevention_Cheat_Sheet.md#rule-6---обработка-html-разметки-с-использованием-специальных-библиотек).

# Предотвращение межсайтового выполнения сценариев (XSS) и политика защиты содержимого

Все проверяемые пользовательские данные должны проходить обработку перед возвращением на html-страницу с целью предотвращения выполнения вредоносного кода (например, межсайтового выполнения сценариев). Таким образом, `<script>` должно возвращаться в виде `&lt;script&gt;`

Способ обработки зависит от контекста страницы, на которой пользователь вводит данные. Например: преобразование HTML-сущностей подходит для данных, размещаемых в теле HTML; однако данные, предоставляемые пользователем в составе сценариев, должны подвергаться специальному преобразованию JavaScript.

Более подробную информацию по предотвращению XSS см. здесь: [Памятка OWASP по предотвращению межсайтового выполнения сценариев](Cross_Site_Scripting_Prevention_Cheat_Sheet.md)

# Проверка загружаемых файлов

Большинство сайтов позволяет пользователям загружать файлы (например, изображения для профиля). Данный раздел помогает обеспечить безопасность работы данной функции.

Дополнительную информацию по защите загрузки можно найти здесь: [Памятка по обеспечению безопасности функции загрузки файлов](Protect_FileUpload_Against_Malicious_File.md).

## Проверка загрузки

- Используйте проверку входных данных для подтверждения типа расширения загружаемого файла.
- Убедитесь в том, что размер загружаемого файла не превышает максимально допустимый.
- Если на сайте поддерживается загрузка ZIP-файлов, выполняйте проверки перед их распаковкой. Проверяйте путь распаковки, уровень сжатия, приблизительный размер распакованных данных.

## Хранение загружаемых данных

- При сохранении файлов в системе давайте им новые имена. Не используйте указанные пользователем имена для сохраняемых или временных файлов.
- При загрузке файлов в веб-приложение переименовывайте их перед сохранением. Например: имя загружаемого файла — *test.JPG*, переименуйте его в *JAI1287uaisdjhf.JPG*, используя произвольные символы. Цель данной операции — предотвращение прямого доступа к файлам и неоднозначности имен, позволяющей обойти фильтрацию, как в случае с `test.jpg;.asp или /../../../../../test.jpg`.
- Проверяйте загруженные файлы на наличие вредоносного контента, используя, например, средства защиты от вредоносного ПО или статический анализ.
- Путь к файлу должен задаваться на стороне сервера, а не на стороне клиента.

## Обработка загруженного контента

- Убедитесь, что загруженные изображения имеют корректный тип содержимого (например, image/jpeg, application/x-xpinstall).

## Обработка "специальных" файлов

В функции загрузки необходимо использовать белые списки, разрешающие только определенные типы файлов и расширений. При этом необходимо учитывать следующие типы файлов, загрузка которых может привести к появлению уязвимостей:

- **crossdomain.xml** и **clientaccesspolicy.xml:** aпозволяют осуществлять междоменную загрузку данных во Flash, Java и Silverlight. Использование этих файлов на сайтах с аутентификацией может привести к междоменной краже данных и межсайтовой подмене запросов. Обнаружить подобное бывает довольно сложно, особенно в некоторых версиях плагинов, поэтому наилучшим решением будет запрет на использование файлов с именем “crossdomain.xml” или “clientaccesspolicy.xml”;
- **.htaccess** и **.htpasswd:** содержат параметры конфигурации сервера для каждого каталога и должны блокироваться. См. [документацию HTACCESS](http://en.wikipedia.org/wiki/Htaccess);
- рекомендуется блокировать исполняемые веб-сценарии, такие как `aspx, asp, css, swf, xhtml, rhtml, shtml, jsp, js, pl, php, cgi`.

## Проверка загрузки

- Используйте библиотеки перезаписи изображений для проверки изображений и удаления постороннего контента.
- Устанавливайте расширение сохраняемого изображения, исходя из его типа содержимого, определенного при обработке изображения, а не просто по заголовку из загрузки.
- Убедитесь, что определенный тип содержимого присутствует в перечне разрешенных типов изображения (например, jpg или png).

# Email Address Validation

## Email Validation Basics

Many web applications do not treat email addresses correctly due to common misconceptions about what constitutes a valid address. Specifically, it is completely valid to have an mailbox address which:

- Is case sensitive in the local portion of the address (left of the rightmost `@` character).
- Has non-alphanumeric characters in the local-part (including `+` and `@`).
- Has zero or more labels.

At the time of writing, [RFC 5321](https://tools.ietf.org/html/rfc5321) is the current standard defining SMTP and what constitutes a valid mailbox address. Please note, email addresses should be considered to be public data.

Many web applications contain computationally expensive and inaccurate regular expressions that attempt to validate email addresses. Recent changes to the landscape mean that the number of false-negatives will increase, particularly due to:

- Increased popularity of sub-addressing by providers such as Gmail (commonly using `+` as a token in the local-part to affect delivery)
-  New [gTLDs](https://en.wikipedia.org/wiki/Generic_top-level_domain) with long names (many regular expressions check the number and length of each label in the domain)

Following [RFC 5321](https://tools.ietf.org/html/rfc5321), best practice for validating an email address would be to:

- Check for presence of at least one `@` symbol in the address.
- Ensure the local-part is no longer than **64 octets**.
- Ensure the domain is no longer than **255 octets**.
- Ensure the address **is deliverable**.

To ensure an address is deliverable, the only way to check this is to send the user an email and have the user take action to confirm receipt. Beyond confirming that the email address is valid and deliverable, this also provides a positive acknowledgement that the user has access to the mailbox and is likely to be authorized to use it. 

This does not mean that other users cannot access this mailbox, for example when the user makes use of a service that generates a throw away email address.

- Email verification links should only satisfy the requirement of verify email address ownership and should not provide the user with an authenticated session (e.g. the user must still authenticate as normal to access the application).
- Email verification codes must expire after the first use or expire after 8 hours if not used.

## Address Normalization

As the local-part of email addresses are, in fact - case sensitive, it is important to store and compare email addresses correctly. To normalise an email address input, you would convert the domain part ONLY to lowercase.

Unfortunately this does and will make input harder to normalise and correctly match to a users intent. It is reasonable to only accept one unique capitalisation of an otherwise identical address, however in this case it is critical to:

- Store the user-part as provided and verified by user verification.
- Perform comparisons by `lowercase(provided)==lowercase(persisted)`.

# Authors and Primary Editors

Dave Wichers - dave.wichers@aspectsecurity.com